블록체인을 만든 이유
    -누구나 다 볼 수 있지만 바꿀 수 없기 때문에
    -블록에 담기는 데이터가 트랜잭션이다 그 데이터는 바뀌지 않는다
    -트랜잭션이 블록에 담겨야 의미가 있는 것이다

    -블록에 담기는 건 수수료에 따라 결정된다 수수료가 높은 거래가 먼저 담긴다
    -트랜잭션 만들어지면 다 전파를 하고 생태계에 올릴것이다
    -순서만 대충 정해서 (수수료 개념이 없기 때문에) 블록에 데이터로 담을 것이다

===================================================
txOut에 있는 것들을 모두 모아서 확인해보면 내가 가지고 있는 코인(balance)를 알 수 있다

내가 보유한 TxOuts 10, 15, 20, 40
내가 지금 만들고 싶은 트랜잭션 코인 60 -> 앞에서 부터 다 더해서 85인걸 확인 60보내고 25는 나에게 다시 보냄

트랜잭션 풀을 가공해서 리턴 하는 함수로 만든이유
    트랜잭션 풀에 배열이 들어갈 것이다
    그 배열은 오브젝트안에 다른 데이터들이 담겨 있는 모양으로 복잡시럽다
    이 것을 그냥 변수로 쓰거나 return 변수라는 함수를 만들어도 얕은복사만 된다
    얕은 복사는 같은 주소를 공유하기 때문에 다른 파일에서 import해와서 안의 값을 바꾸게 되면 원래 것을 바꾸게 된다
    => 같은 메모리에 접근하는 변수 두개
    깊은 복사는 새로운 메모리에 같은 값을 담는것

[...]는 깊은 복사가 되긴 하지만 한단계만 된다(배열 안의 배열은 얕은 복사가 된다)

>TODO
JSON.parse(JSON.stringify())는 안쪽에 것도 될까?

트랜잭션 풀에 있는 인풋 내용은 누군가가 아웃풋한 내용이 서명되 있는것이다
filterTxPoolTxs 는 내가 서명한 input(내가 올린애)인지 확인하는 함수

const unsignedTxIns = includeTxOuts.map(createUnsignedTxIn); 이게 가능한 문법이냐